README Ð C++ - Project02
Nathan Gould, Brooks Wegmann
CSC435-1 Programming Languages

How to compile/run
	Compile using the makefile provided ("make driver")
	Input program should be piped in while the grammar file should be given as a command line argument. A correct run of the program should read:
		cat input.txt | ./driver grammar.txt

In this project, we defined multiple 2D int vectors to hold our data. We gave a unique number to the terminals and nonterminals in the grammar scanned in. This allowed us to generate first, follow, and predict sets for our grammar. Specifically, we calculated first sets by iteratively going through specified productions. When we encountered a nonterminal, we pushed that number onto the back of its corresponding first_set vector. If we encountered a nonterminal, then we would iterate through that specific nonterminals productions. To calculate follow sets, we needed to loop through all the productions, all the elements in those productions, and then all of those elements multiple times in case those elements would generate epsilon. When looking at a nonterminal, we would add the first_set of the element immediately after. If that element could generate epsilon, we would look at the next element, so on and so forth. By doing this, our follow sets only contained elements part of first sets. We then had to loop through all the productions again, this time checking if a nonterminal was at the end of a production. If this occurred, then the follow of the left_hand_side would be added to the follow of that nonterminal. Doing this gave us complete follow sets of all nonterminals. Using the first and follow sets, we then had to get the predict sets of all the productions.  By looping through all the productions, and elements in those productions (just like in follow sets) we were able to get the predict sets. With the predict sets we were able to generate a parse table. By looping through the predict sets, we could save that production number at the index of the corresponding terminal/nonterminal pair.  We have one abnormality where our parse table is generated with an extra row populated with zeros (as we initialize all elements of the table to be zero).

We chose to use vectors as our primary data storage method for simple iteration using the vector::size() method and simple addition to the vectors using the push_back method. It also gave us flexibility in initialization as the dynamic nature of vectors allowed the size of a given vector to be unknown at the time of declaration. For that reason, often vectors will be initialized with a size of 0 and then pushed into - thus crreating a vector only of the size needed for each of the elements in the vector. This likely produces come considerable overhead, especially considering the number of vectors and the frrequency with which they must be iterated upon. Luckily, the project description specificed that grammars would have small numbers of terminals (and hence, likely a small number of productions, especially with the constraint that grammars be LL(1).

Error checking in parsing is implemented as specified in the project description. However, errors in malformed grammars (errors regarding input data not being as expected) are not being accounted for. When generating the parse table, there are checks to ensure that not one element of the parse table is assigned more than once, which should catch errors regarding non-LL(1) input grammars. We have also taken a very straightofrward approach of having one single file containing all of the methods and procedures that are necessary to both generate data structures and parse input. Given a chance to work on this more, these would be our two priorities: better error checking, and a more object-oriented approach to the problem.

